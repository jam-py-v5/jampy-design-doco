============
Demo project
============

After downloading the Jam.py package, and starting _`Demo`, the application is accessible with typing 127.0.0.1:8080/index.html or just 127.0.0.1:8080 in the Browser:

.. image:: _images/demo.png
	:scale: 70 %
	:align: center
	:alt: Demo application


The Application Builder is accessible with typing 127.0.0.1:8080/_`builder.html` in the Browser:

.. image:: _images/demo_admin.png
	:scale: 70 %
	:align: center
	:alt: Application builder of demo project


The Application is derived from Open Source Chinook Database. It is an Invoicing example with music tracks as invoiced products,
Customers, Albums, etc. Basically, the application creates a Customer details, product details, and raises Invoices for Customers. That is it.
Cool little application, though.

As mentioned, Demo application is derived from it, it is not a one-to-one mappings of all database fields and relations. We need to start from somewhere, right?


Demo database
=============

To better understand the actual database, here is the original _`Chinook` relational database diagram:

.. image:: _images/chinook.png
	:scale: 50 %
	:align: center
	:alt: Chinook Database

Why is the above diagram important? Because it is demonstrating the tables Primary and Foreign Keys, which are essentially a table `Lookup fields`_ used within Jam.py. More about that latter.

So now that we know what the Demo application is all about, we can dive into more details. First, what can we actually expect from Jam.py?


What to expect?
================

Low code is what everyone talks about. Below is what Jam.py provides with no coding needed at all, at least not for this Demo. The code does exist, it is there. Otherwise the application would not work at all. However, this only means that no coding is required by us to build similar applications. Because the code is there, and is available to us, this also means we can adapt the existing code for our requirements. Mostly, it is a copy/paste from this Demo, with some minor changes for the application we are building. This is important to understand. Jam.py is providing many bells and whistles, or so called batteries, out of shelf. However, Jam.py is not "Out of Shelf Application"! It is a framework, so we build applications within the constraints of the framework. 

Just like Django's MVC. When building applications with Django, we operate within the similar constraints. Both frameworks are flexible enough for the job at hand. The main difference is the task, or the application. Django could build the Jam.py application, but it would be overkill, since Jam.py is way more specialised in doing so. Jam.py is a specialised framework. It is the right tool for the right job. Let's see what can we expect from it.


DropDown Menu(s)
----------------

On the below menu all options on the left are created automatically. The "About" and "Jam.py" on the right side is a code. We can build complete menu manually, not to worry. Will get there soon.

.. image:: _images/demo_menu.png
	:scale: 70 %
	:align: center
	:alt: Automated Menu




Data Grid(s)
------------


The Demo Invoices data grid is called a Journal. In Accounting, this are General Ledger tables. In databases, this is a Master Table. This grid is presented automatically, with pagination on the bottom and can contain History button, refresh and Filters button. This are the default options, and can be turned off. If some none default button is needed, it can be added with a code though.
Did I mention search for any field, and sorting for any field? It's automated.

What is also done by Jam.py with no code is a summary for any numerical field or a number of records for other fields.
As seen, the Invoices data grid is presented as Tab. As we open more grids, more Tabs will appear here automatically. Tabs Caption can be changed with a code. What we see initially is the default.

.. image:: _images/demo_master.png
	:scale: 70 %
	:align: center
	:alt: General Ledger tables

More Data Grid(s)
-----------------

The Demo Invoices data has a Details grid. This are the `Invoice items`_ details. They are created automatically and can contain summary fields and sorting. The "Total" field visible is a code! What is not visible is editing directly in the grid! 
There can be any number of details data grids. Now, that is actually pretty impressive. Any number, huh? Will get there.

As above grid, each Details grid is presented in Tabbed format. More Details added to an Journal, more Tabs we see in here. 

.. image:: _images/demo_detail.png
	:scale: 70 %
	:align: center
	:alt: Invoices items tables



Data Grid Header/Footer
-----------------------

Automatically provided is a classic New/Delete/Edit option for any Data Grid. It can exist on the Top/Bottom of some data Grid, hence I call it Header/Footer. It can also contain other buttons or a menu, which is a code driven, so coding is needed.

.. image:: _images/demo_footer.png
	:scale: 70 %
	:align: center
	:alt: Data Grid Footer/Header 


Ok, do not want to go further, just a minimum to get us going.


Any questions?
--------------

So now that we covered the first thing we see on the Demo application, any questions?


All of the above is driven by the Builder GUI. We might be saying no big deal, but it actually is a big deal! Because to code this from the beginning, like with Django, one would need years and years of coding experience to cover for all scenarios possible. Or a team of dedicated developers.

I am ignoring the Reports and Analytics for now, visible on Demo application. Concentrating only on no-code or low-code. Both mentioned features require some coding experience. Not much, but still needed.

 


Ok, how do I start?
===================

If no questions (cough, cough), I think we should first start with building some tables. Since we are doing Invoices, lets start with this. It is sort of top to bottom approach!


Invoices
--------

For an invoice, we need a Customer, some Product and somewhere to store invoiced data. Like a Journal. To be fair, Journal is just a name. We do not really need to stick to the Jam.py Demo application naming! Rename anything to whatever floats your boat!

.. image:: _images/demo_journal.png
	:scale: 70 %
	:align: center
	:alt: Editing Journal


We can rename Journals caption to anything, since this is just a Caption. However, the Name can be used in the code somewhere, so it is always 
advisable to use "Find" built-in option to search where some Name is used.

On above screenshot we see the “Deleted Flag” and “Record ID”. This is just a bit of automation. When we create a new table in Journals group, these 
two records will be created automatically. We can think of this as a table Template.

_`Master field` field seen above is also a feature. In Demo application, Invoices table, it is used to identify which item belongs to which Invoice.

.. note::
	`Master fields are not real fields in the database, they get populated when we select a value in the Lookup field.`

This is actually very powerful feature in my books, because it quickly identifies stuff. Which stuff we might ask? Anything built as a `Lookup fields`_. So we set the "Master Field" to "Customer", for everything related to "Customers" table we are pulling the data from.

I would leave it here for now but just note that "Master field" can be also achieved with a code for Imported tables. Usually, the Imported tables are 
from some other system, like MSSQL or MySQL, hence not created by Jam.py. In this case we can add the table as detail to only one master. With "Master 
field" Jam.py feature we can do much more. We will get to this latter.

Only Invoices, _`Invoices Items`, and Tracks are using "Master field" in Demo application. 

The Demo Invoices table:


.. image:: _images/item_editor_dialog.png
	:scale: 80 %
	:align: center
	:alt: Invoices table

We see that Invoices table is referencing a lot from the Customers table! This is where we look at the `Chinook`_ database, we see the relation 
Customers - Invoices! 

This means we can create the table but with no Customers one, we can't really achieve what is needed for Invoices to function correctly. 

With no Customers table our Invoices table would look like this:


.. image:: _images/item_editor_dialog_blank.png
	:scale: 80 %
	:align: center
	:alt: Invoices table with no Customers


It is exactly the same thing, same as above one would think. Not really. It would not display any data because Jam.py would assume that all of Customers data is coming from one, and only one table, which is Invoices table. It is also true that all fields would have the Integer Type, which is not quite right. It is presented here just as an example and it is not the right way of doing it.

However, from the diagram, the Invoices is pulling some data from Customers and "Invoice Items" table. That is the Holy Grail of any application building. Pulling data from here and there, and showing the result with no code, or low code, is exactly what Jam.py does. We call that a `Lookup fields`_.
 

As seen, on the right hand side checked options are "Visible", "Soft Delete", "History" and "Edit lock". Refer to `Item Editor dialog`_ for more info.

Also, worth mentioning is that Invoices do contain a `tiny code`_ for calculating "Tax" and "Total" column. It also utilises Jam.py feature to alert the User with a custom message. It does that on Editing only. 

Here we touch the _`View/Edit` option on `builder.html`_. When we click on Journals/Invoices, there is a "View Form" option on the right hand side. 



.. image:: _images/demo_inv_view.png
	:scale: 80 %
	:align: center
	:alt: Invoices table view

Here we control the layout, sorting and summary fields, as well as fields visibility on the Demo data grid. On the Form tab, we see a number of other options, but most importantly the "View detail" option, with selected "Invoice table". We can select as many Details as we like, providing they exist. If no detail is selected, there would be nothing to display. Somehow counter-intuitive on the first instance, however we are controlling the visibility with this option, not more than that.

.. image:: _images/demo_inv_form.png
	:scale: 80 %
	:align: center
	:alt: Invoices table view form


Similar for Edit option. Exclude or select for editing whatever is necessary, as well as details needed for editing. While on it, we can also control how to present the edit form in the sense of tabs or bands. This is done on "Plus" icon on the left hand side. I would encourage to play with this options, it is quite subjective what and how something should be presented.  

.. image:: _images/demo_inv_edit_form.png
	:scale: 70 %
	:align: center
	:alt: Invoices table edit form


.. _Item Editor dialog: https://jampyapplicationbuilder.com/docs/admin/items/item_editor_dialog


Customers
---------

Back to Customers, if we visited `Tutorial. Part 1. First project`_ in the Doc's, I hope it is pretty much clear how to create a simple CRM. Hence, Demo application has Customers table as well, which is consumed by the Invoices table.


Here is how Customers table looks like:

 
.. image:: _images/demo_customers.png
	:scale: 80 %
	:align: center
	:alt: Customers table


It is a simple table with no lookups to some other tables, like Invoices for example. Because it is derived from the `Chinook`_ database, we can see that Demo is missing the Employees table, so the SupportRepid is not used anywhere. That is fine. No harm done. We might argue that Customers table can be split in more tables, like Country, State or similar. While on it, please see `Tutorial. Part 2. File and image fields`_ for adding Image field. We did touch base with the `View/Edit`_ option on Invoices, no need for repeating. 


Now that we have two tables in place, we can set the _`Lookup fields` in Invoices in a similar fashion as in `Tutorial. Part 1. First project`_.

We did not touch the third table yet, which is the "Invoice items". This is the part of `Tutorial. Part 3. Details`_

.. _Tutorial. Part 1. First project: https://jampyapplicationbuilder.com/docs/intro/tutorial01/index.html

.. _Tutorial. Part 2. File and image fields: https://jampyapplicationbuilder.com/docs/intro/tutorial02/index.html

.. _Tutorial. Part 3. Details: https://jampyapplicationbuilder.com/docs/intro/tutorial03/index.html

 

Invoice items
-------------

To automatically add some details to some other table, with no code what so ever, we need to use Jam.py Details feature.

Why would we do that? Well, we could opt for coding. It is available feature and used mostly for Imported tables, which do not contain additional fields Jam.py is using. 

However, Demo application is demonstrating how Jam.py is functioning, so why not using it. 

Basically, since the Invoice Table is a detail of the master table Invoices, it has the **master_rec_id** field that stores a reference to an invoice. As a master record, we can show an invoice that contains the current item. Clear as mud?

The Details Group differs from other default tables slightly:

.. image:: _images/demo_details_group.png
	:scale: 80 %
	:align: center
	:alt:  Detail Group


See the additional fields? The fields in question are master_rec_id and master_id. This fields do not exist in any legacy systems. None of the applications out there are using it. However, let's not be afraid of this feature. As mentioned, we can and we will achieve the Jam.py functionality with a bit of code for legacy systems without this fields. 

In addition, the option "Visible" is unchecked. It makes no sense in setting the Details as visible, since we edit/view them within the Invoices only. It is possible to set it as visible, though.

Just like before with Invoices table, but not with Customers, the "Invoice Table" is referencing two tables, "Tracks" and "Customers". 


.. image:: _images/demo_details.png
	:scale: 80 %
	:align: center
	:alt:  Invoice Items


If below table screenshot was the "blank" Invoice Items table, with no `Lookup fields`_ to the above two tables, it would not show anything. The reason 
why we using "Customers" table and not the "Invoices", InvoiceId from `Chinook`_ database diagram, is the presentation. It is more nicely presented 
with the customer last name on the screen than with some meaningless number. In this case it is InvoiceId (integer), as on the diagram, which 
ultimately identifies the Customer by the CustomerID. Similar with Tracks, we are using it to do the Lookup on a completely different tables, namely 
"Albums" and "Artists".


.. image:: _images/demo_blank_details.png
	:scale: 80 %
	:align: center
	:alt:  Invoice Items with no lookups



Same mantra, we look at the database diagram. We "dive" deep from "Invoice Items" to "Tracks" to "Albums" and finally to "Artists".

We are using the power Jam.py feature - lookups, as much as we can to minimise coding. Just imagine the SQL needed to "join" the three tables! To provide the exact SQL, here is what Jam.py generates automatically as the last SQL query when we open Invoices:

.. code-block:: sql


    SELECT "DEMO_INVOICE_TABLE"."ID", "DEMO_INVOICE_TABLE"."DELETED", "DEMO_INVOICE_TABLE"."MASTER_ID", 
    "DEMO_INVOICE_TABLE"."MASTER_REC_ID", "DEMO_INVOICE_TABLE"."TRACK", "DEMO_INVOICE_TABLE"."QUANTITY", 
    "DEMO_INVOICE_TABLE"."UNITPRICE", "DEMO_INVOICE_TABLE"."AMOUNT", "DEMO_INVOICE_TABLE"."TAX", 
    "DEMO_INVOICE_TABLE"."TOTAL", "DEMO_INVOICE_TABLE"."INVOICE_DATE", "DEMO_INVOICE_TABLE"."CUSTOMER", 
    DEMO_TRACKS_43."NAME" AS TRACK_LOOKUP, DEMO_TRACKS_43_ALBUM."TITLE" AS ALBUM_LOOKUP, DEMO_TRACKS_43_ALBUM_ARTIST."NAME" 
    AS ARTIST_LOOKUP, DEMO_CUSTOMERS_329."LASTNAME" AS CUSTOMER_LOOKUP FROM "DEMO_INVOICE_TABLE" AS "DEMO_INVOICE_TABLE" 
    OUTER LEFT JOIN "DEMO_TRACKS" AS DEMO_TRACKS_43 ON "DEMO_INVOICE_TABLE"."TRACK" = DEMO_TRACKS_43."ID" OUTER LEFT JOIN 
    "DEMO_ALBUMS" AS DEMO_TRACKS_43_ALBUM ON DEMO_TRACKS_43."ALBUM" = DEMO_TRACKS_43_ALBUM."ID" OUTER LEFT JOIN 
    "DEMO_ARTISTS" AS DEMO_TRACKS_43_ALBUM_ARTIST ON DEMO_TRACKS_43_ALBUM."ARTIST" = DEMO_TRACKS_43_ALBUM_ARTIST."ID" OUTER 
    LEFT JOIN "DEMO_CUSTOMERS" AS DEMO_CUSTOMERS_329 ON "DEMO_INVOICE_TABLE"."CUSTOMER" = DEMO_CUSTOMERS_329."ID" WHERE 
    "DEMO_INVOICE_TABLE"."DELETED"=0 AND "DEMO_INVOICE_TABLE"."MASTER_ID"=16 AND "DEMO_INVOICE_TABLE"."MASTER_REC_ID"=464 
    ORDER BY DEMO_TRACKS_43_ALBUM."TITLE", DEMO_TRACKS_43."NAME"

There we go! We can easily copy/paste the above SQL query into some utility to browse the data in demo.sqlite database. Just imagine coding this type of query for all possible combinations of tables. Btw, this SQL extract is possible by changing the Jam.py `source code`_.

.. _source code: https://groups.google.com/g/jam-py/c/twlRyMYHMwc/m/c5sbpTQJBQAJ



Now we execute `Tutorial. Part 3. Details`_


.. _Tutorial. Part 3. Details: https://jampyapplicationbuilder.com/docs/intro/tutorial03/index.html

 
How did we go?
--------------

So, did we manage to get the Invoices with details up? It is quite common for the first timers to miss the "Details" button on the right hand side of Invoices in `builder.html`_.

On the `CRM`_ example, the Details is a "to-do-list". If all went ok, we should have a project page similar to Demo. 



.. _CRM: https://jampyapplicationbuilder.com/docs/intro/tutorial03/index.html


Click on!
----------

With the expectations and basics covered, we can double click on any Invoices row. If all good, we see one invoice with the invoice items included.

 
.. image:: _images/demo_inv_edit.png
	:scale: 80 %
	:align: center
	:alt:  Edit Invoice 



If nothing was touched or changed, this is how it looks like. Job done. All created automatically, no code yet! Except for "Tax" and "Total".

See how almost everything related to Customer is greyed out? This is because of the `Master field`_! Only one field on the Invoices table is not using "Master field" and this is a Customer field. Hence, only that field won’t be greyed out, because we are using it to define all other fields on the Form. For sure we are not updating the "Invoice Date" from anywhere, it is defined with a little code. Same with "Tax", "SubTotal" and "Total".


Your 1st task!
--------------

As mentioned, we can edit anything directly in the data grid! The changes will be picked immediately and saved in the database.

Your first task is to find the option which enables editing in the data grid.

It looks like this:

.. image:: _images/demo_inv_edit_field.png
	:scale: 70 %
	:align: center
	:alt:  Edit Invoice  




And why not reshuffling the Invoices edit form a bit?

To look similar to this:

.. image:: _images/demo_inv_1.png
	:scale: 70 %
	:align: center
	:alt:  Edit Invoice  




Very good, we are getting there! 

I am not sure if more info is needed about the data grid and forms layout. Just note that the Menu is created from the `builder.html`_ Groups layout, so whatever is showing here first, it will be shown as first on the Menu.

If we quickly want to change the application starting view to ie Customers, we just change the Groups order.

Maybe we can go now through a code.


A little code
=============


If one is a beginner with any sort of coding, this might be a bit daunting. However, I can assure you, the developers out there are using copy/paste just like anyone else. So, with a bit of persistence, one can reuse the code from Demo application and get impressive results. This is particularly true for Dashboards, which is a flag Jam.py feature. We included more than 15-20 graphs for some applications, with a minimal change for each. For example, just changing "pie" to "bar" changes the graph appearance.

The official documentation has heaps of code applicable to Demo application. Here will try to explain where exactly the code is used and a bit about why.
Again, we touching only the additional code applicable for Demo, the default one which comes with a blank and empty project is not discussed.


Invoices
--------

In Invoices, it is quite obvious that some calculations are happening "on the fly". At the moment, Jam.py v5 has no feature to calculate fields automatically, driven by visual application `builder.html`_. The new major Jam.py version might include this option. This might be a put off for some users or a "would be" developers and the reasoning is that major players, like PowerApps, have that. Sure, they also have a bottomless financing, if you follow my drift.

Here is the _`tiny code` for _`Demo application version` 1.5.30. The code can be found on "Client module", after selecting Invoices:

.. code-block:: js

 
        function on_field_get_text(field) {
            if (field.field_name === 'customer' && field.value) {
                return field.owner.firstname.lookup_text + ' ' + field.lookup_text;
            }
        }

        function on_field_get_html(field) {
            if (field.field_name === 'total') {
                if (field.value > 10) {
                    return '<strong>' + field.display_text + '</strong>';
                }
            }
        }

        function on_field_changed(field, lookup_item) {
            var item = field.owner,
                rec;
            if (field.field_name === 'taxrate') {
                rec = item.invoice_table.rec_no;
                item.invoice_table.disable_controls();
                try {
                    item.invoice_table.each(function(t) {
                        t.edit();
                        t.calc(t);
                        t.post();
                    });
                }
                finally {
                    item.invoice_table.rec_no = rec;
                    item.invoice_table.enable_controls();
                }
            }
        }

        function on_detail_changed(item, detail) {
            var fields = [
                {"total": "total"}, 
                {"tax": "tax"}, 
                {"subtotal": "amount"}
            ];  
            item.calc_summary(detail, fields);
        }

        function on_before_post(item) {
            var rec = item.invoice_table.rec_no;
            item.invoice_table.disable_controls();
            try {
                item.invoice_table.each(function(t) {
                    t.edit();
                    t.customer.value = item.customer.value;
                    t.post();
                });    
            }
            finally {
                item.invoice_table.rec_no = rec;
                item.invoice_table.enable_controls();
            }
        }

As seen, the Client module contains five JavaScript functions. First two functions deal with text formatting. 
The *on_detail_changed* is using Jam.py built in function `calc_summary`_. 

.. _calc_summary: https://jampyapplicationbuilder.com/docs/refs/client/item/m_calc_summary.html

Lastly, one of the most important function and the most commonly used is:

.. js:function:: on_field_changed

.. code-block:: js

        function on_field_changed(field, lookup_item) {     <- 1.
            var item = field.owner,                         <- 2.
                rec;
            if (field.field_name === 'taxrate') {           <- 3.
                rec = item.invoice_table.rec_no;
                item.invoice_table.disable_controls();
                try {                                       <- 4.
                    item.invoice_table.each(function(t) {
                        t.edit();
                        t.calc(t);
                        t.post();
                    });
                }
                finally {                                   <- 5.
                    item.invoice_table.rec_no = rec;
                    item.invoice_table.enable_controls();
                }
            }                                               <- 6.
        }

Understanding this function is quite important. It provides a mechanism to control what happens when some **input** on
the application is **changed**.

Steps:

1.
In this case we are looking to “monitor” the “taxrate” field, let’s say because it is important (no better explanation for now),
and we are hoping to change the relevant `Lookup fields`_. Which is a lookup to a different table, right? We are changing “Tax Rate”
in Invoices table, but at the same time expect the changes in “Invoices Items”.

2.
In plain, down to Earth language, we define some "shortcuts" here. See how *item* is repeating in the code? Hence, a "shortcut".

.. note::

	When copy/paste the code, it is not obvious that "item" is not there as it should be. So the best is to look at the code 
	we *know* that is working. Like customers.js at Demo/Customers Client Module, etc.
	
Consider this example:

.. code-block:: js

	function on_field_changed(field) {
    		if (item.field_name === 'pattern_type') {
                .
                .

That is not going to work. Simply because it is missing **"var item = field.owner"**.

3.
This is where the magic happens. We "test" the field name if is the required one. If not, nothing happens and goes straight to Step 6, which is "the end". Because this is typical "if" clause, better use "try" and  "finally" in it, steps 4. and 5. respectively. 

With **"rec = ..."** we define all records needing changing, after the "taxrate" changes. 
With **"...disable_controls"** we disable all buttons (control items) temporary, as we do not want something actioned on while working on changing records.

4.
Then we "try" to update all records with a nice function **".each(...)"**. Which does "edit", "_`calc`" and finally "post". 
We use "edit" to open every single record for editing, and "post" to post everything back via API. This is the "POST" part, correct? Without it, the data would not be saved. 

.. note::
    The function - "calc", does the actual calculation on records. The function is in "Journals/Invoices/InvoiceTable" Client Module.

5.
And "finally", we show the results back with **"item... = rec"** and enable the buttons, etc. with **"...enable_controls"**.

6. 
If the field name was not the one we are after, exit the "if" clause here. 


That is it. With six little steps we did a calculations JavaScript program. 

.. note::
    No calculation will happen with a field valued as _`null`.

It is absolutely needed to check the condition before expecting that the calculation will go through.

Error handling!
---------------

As with above `null`_, when doing something, it is always advisable to use `best practises`:

.. note::

    One of the main obstacles with using **"on_field_changed"** is a infinite loop happening. For example one field changing the field we are expected to "monitor".

The following algorithm can be used to avoid this situation:

.. code-block:: js

        let calculating;

        function on_field_changed(field, lookup_item) {
             if (!calculating) {
                calculating = true;
                try {
                     // some calculations 
                }
                finally {
                    calculating = false;
                }
            }
        }

For more information please visit the mailgroup `error thread`_.

.. _error thread: https://groups.google.com/g/jam-py/c/_HhCO1Rsoy4/m/wqJeeVp1BgAJ



So, how was it?
---------------

Is the above to much? Or easy to follow and apply in some other scenario?

To expand a bit on **"on_field_changed"**, please visit `Conditional formatting`_ mailgroup thread or search the 
mailgroup for the same. There are a number of scenarios where to apply **"on_field_changed"**, and this is just a touch 
of the surface. One possible scenario is changing the password. Again, the best is to search the mailgroup.



.. _Conditional formatting: https://groups.google.com/g/jam-py/c/qDlZnWfLsrc/m/XXyvOCS1AgAJ


More code
==========

As mentioned, the `calc`_ function exists outside the code used in Invoices Journal. Why? Because there might be many Details in some Journals, and placing them in one single place is not flexible enough. Simply put, an function, for example
**on_field_changed**, would overwrite the same function if there is a need for two same functions.  

Invoices Details
------------------

Here is what is in the Journals/Invoices/InvoiceTable, note the *on_field_changed* function again:

.. code-block:: js

        function calc(item) {
            item.amount.value = item.round(item.quantity.value * item.unitprice.value, 2);
            item.tax.value = item.round(item.amount.value * item.owner.taxrate.value / 100, 2);
            item.total.value = item.amount.value + item.tax.value;
        }

        function on_field_changed(field, lookup_item) {
            var item = field.owner;
            if (field.field_name === 'track' && lookup_item) {
                item.unitprice.value = lookup_item.unitprice.value;
            }
            else if (field.field_name === 'quantity' || field.field_name === 'unitprice') {
                calc(item);
            }
        }

        function on_view_form_created(item) {
            var btn = item.add_view_button('Select', {type: 'primary', btn_id: 'select-btn'});
            btn.click(function() {
                item.alert('Select the records to add to the invoice and close the from');
                item.select_records('track');
            });
        }

        function on_after_append(item) {
            item.invoice_date.value = new Date();
        }


It needs to be stressed that *details* can "live" with absolutely no code on Details tree within the 
`builder.html`_! However, when we *attach* the detail to some Journal (`Tutorial. Part 3. Details`_), probably some code is needed there. And that is exactly the above example.

Because the details store `Invoices Items`_, so basically products, the `calc`_ code exist here and only here. It is only relevant to Items, right?


The new functions presented here are:

.. js:function:: on_view_form_created
.. js:function:: on_after_append  


It is quite obvious what the function **on_view_form_created** does. It creates a "Button" and assigns a function to it so when the button is clicked, it shows the JavaScript message 
and presents a form to select some products. All of this in just five lines of code.

Function **on_after_append** just adds the current date on a form.

We are almost there with the final Demo Invoices code! Hold on!



Server code
===========

This is where Python programming language kicks in. Everything in Jam.py
as the Server code is Python.



Invoices
---------

The last code remaining for Invoices is the Server Module code. 

If we click on Journals/Invoices "Server module" as on `builder.html`_, this is the code:

.. code-block:: Python


        def on_apply(item, delta, params, connection): 
            tracks = item.task.tracks.copy(handlers=False)
            changes = {}
            delta.update_deleted()    
            for d in delta:
                for t in d.invoice_table:
                    if not changes.get(t.track.value):
                        changes[t.track.value] = 0
                    if t.rec_inserted():
                        changes[t.track.value] += t.quantity.value
                    elif t.rec_deleted():
                        changes[t.track.value] -= t.quantity.value                
                    elif t.rec_modified():
                        changes[t.track.value] += t.quantity.value - t.quantity.old_value
            ids = list(changes.keys())
            tracks.set_where(id__in=ids)                
            tracks.open()
            for t in tracks:
                q = changes.get(t.id.value)
                if q:
                    t.edit()
                    t.tracks_sold.value += q
                    t.post()
            tracks.apply(connection)

Here is where quite important function is introduced:

.. js:function:: on_apply

There are many `on_apply`_ occurrences in the official documentation since it is the same function name for the Client
and Server operations, JavaScript and Python, respectively. 

.. _on_apply: https://jampyapplicationbuilder.com/docs/refs/server/item/on_apply.html


It is fairly small chunk of code, which mainly deals with changes, inserts or deletion of Items. The code is relevant for
`Demo application version`_ at the time of writing. It can be used for many scenarios if slightly modified.

Not quite sure how to dive into the above code with the explanations with keeping it simple. The official 
documentation might be sufficient. However, why doing it we might ask?


Why Server Code?
--------------------

.. note::
	To answer the above question, the `Server Code` is needed because it is happening in the background. It is almost exactly 
	as the ``stored procedure``, the relational databases are using. It is absolutely possible for an application not to use
	the `Server Code` at all, hence no need for Python. This is the application design choice. If needed, Jam.py can also 
	use the database `stored procedures`.

The relational database engines are quite efficient with the stored procedures. But, and there is a but, is the stored 
procedure portable to a different database products? Of course not. The good news is, Python is portable. Hence, with using 
the `Server Code` Jam.py can successfully run on any platform.  

With some other database engines, or even the Front End Applications like MS Access, for the background operations the Visual Basic
might be used. With MSSQL Server, the database stored procedure can be executed from Access. Either way, the code is needed 
and it would be not portable to a different platform. It is "locked in" for one and only one database product.

Jam.py completely eliminates the above. There is no "lock in" with any specific database product. 

There is also a question of security. It is quite simple to implement the code which controls the permissions on what
can be executed by the user. This is almost the Desktop Application territory! 

And there are even more good news! Debugging. 


Debugging
----------

To debug the `stored procedure` within the relational database, is not for faint hearted. Every developer or 
the DBA would agree. Of course, the more experienced professionals would protect their turf. Again, it is 
business after all. 

However, for a "would be" developer, Python is way easier to learn and debug. And for the professionals, it is 
a breeze.

How to debug is completely down to Python experience, and leaving it to the reader to consult official Python resources.

And finally...
---------------

Below SQL will check for any code in the Application Server Modules (using sqlite3 command line utility):

.. code-block:: sql

	sqlite3 admin.sqlite "select id, f_name,f_server_module  from sys_items where  f_server_module!='' and f_server_module is not null" 

Below sql will check for any code in the Client Modules:

.. code-block:: sql

	sqlite3 admin.sqlite "select id, f_name, f_client_module from sys_items where  f_client_module!='' and f_client_module is not null"


Of course, the Developer would need access to the admin.sqlite database to run the SQL against it. The SQL does not take into
account commented code. 

Here is the list where all `Server code` is on Demo application, hence it can be easily identified within the `builder.html`_:

.. code-block:: sql

	1|Jam.py Demo
	5|Reports
	13|Genres
	15|Tracks
	16|Invoices
	19|Print invoice
	20|Customer purchases 
	22|Customer list
	25|Mail

.. note::
	Note the *ID*! That is exactly the same ID as seen on `builder.html`_! The *Genres* has ID=13, *Tracks* has ID=15, and 
	so on. Hence, we know how many are there and exact location for each Server Module used within the application.

The commented out code, meaning not used at all for Demo, is code with ID=1 (Jam.py Demo). The code should be uncommented when the 
`built in`_ Authentication is turned on.

.. _built in: https://jampyapplicationbuilder.com/docs/how_to/authentication/how_to_authenticate_from_custom_users_table.html

...the End of Code
------------------

Hope you've enjoyed this Code part! The intention was to explain some bits and pieces which were exclusively developed for Demo 
application. For sure there is more code as seen on the above SQL output! However, half of that number is related to Reports.
And we are not going to just Reports yet.


index.html
===========

Here we are introducing the basic index.html structure.


Templates
----------

`Demo`_ application has the "About" and "Jam.py" on the right hand side of the Menu bar. This is a Code as well.

However, it is a bit different to what was discussed above, since the code is related to the index.html file. Btw, this is true for everything else.

If we open index.html file in `builder.html`_ (Task/Project), the below is visible:


.. code-block:: html

            <div id="taskmenu" class="navbar">        
                <div class="navbar-inner">
                    <ul id="menu" class="nav">
                    </ul>
                    <ul id="menu-right" class="nav pull-right">
                        <!--<li id="admin"><a href="#">Application builder</a></li>-->
                        <li id="about"><a href="#">About</a></li>                        
                        <li id="jam"><a href="http://jam-py.com/" target="_blank">Jam.py</a></li>                        
                    </ul>
                </div>
            </div>            


Jam.py calls this html block a _`Template`. 

The "About" and "Jam.py" is simply a link, just as "Application builder" is. Which is _`commented` out.

Hence, everything we want to see here is just a matter of adding it as extra lines. It is quite clear that this Template is related to "menu", and 
it will display on the right hand side. The _`id=` is the most important one, here we see **id** **admin**, **about** and **jam**.

However, this itself is not enough for the proper application functioning. Why? Because the Template does not exist on it's own.
For example, in Django or Flask, the Template might be using a "built in" functionality, like "for loop" clause. Jam.py does not do that.
It does not contain any code for Template in the index.html file.

This must the stressed, in Jam.py, there is no need to "program" the Template. It is a simple html. Ingenious. 


Template Code
-------------

The Template Code for "About" and "Jam.py" is in demo.js (Project/Task/Client Module). It is the default code available for any new project:

.. code-block:: javascript


            $("#menu-right #admin a").click(function(e) {
                var admin = [location.protocol, '//', location.host, location.pathname, 'builder.html'].join('');
                e.preventDefault();
                window.open(admin, '_blank');
            });
            $("#menu-right #about a").click(function(e) {
                e.preventDefault();
                task.message(
                    task.templates.find('.about'),
                    {title: 'Jam.py framework', margin: 0, text_center: true, 
                        buttons: {"OK": undefined}, center_buttons: true}
                );
            });

The **admin** link will just open the new Window, with the `builder.html`_ page. Cool. So this is how we open any page, ie "Help" page for the 
application. The example would be help.html. Try it, create one within the application folder and replace builder.html with help.html!
Obviously, the `commented`_ code prevents this from happening. Uncomment it.

For **about** link, we also see:

.. js:function::  task.templates.find

The function is used to find the **correct** `Template`_ id. In this case the below "about" block in `index.html`_, since the `id=`_ about, which is the 
**class** name "about":

.. code-block:: html

            <div class="about">
                <a href="http://jam-py.com/" target="_blank"><h3>Jam.py</h3></a>
                <h3>Demo application</h3>
                with <a href="http://chinookdatabase.codeplex.com/" target="_blank">Chinook Database</a>
                <p>by Andrew Yushev</p>
                <p>2015-2017</p>
            </div>


That is all to get us going. It should be easy to change the Menu content, and open some pages or a dialogue. 


Wrapping up
-----------

Congrats! Almost everything is covered regarding the Demo functionality! Hope it was not that difficult. 



.. note::
    To Be Continued...
